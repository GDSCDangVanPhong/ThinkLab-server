# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Java CI with Maven

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Set up JDK 24
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml

    # Optional: Uploads the full dependency graph to GitHub to improve the quality of Dependabot alerts this repository can receive
    - name: Update dependency graph
      uses: advanced-security/maven-dependency-submission-action@571e99aab1055c2e71a1e2309b9691de18d6b7d6

    # Store the built artifact for the deploy job
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: spring-boot-app
        path: target/*.jar # Adjust if your JAR name is different, e.g., target/your-app-name.jar

  deploy:
    runs-on: ubuntu-latest
    needs: build # This ensures the deploy job runs only after the build job is successful
    environment: production # You can define environments for better management
    env:
      EC2_HOST: ${{ secrets.EC2_HOST }} # Store your EC2 IP/DNS in GitHub Secrets
      EC2_USER: ${{ secrets.EC2_USER }} # Store your EC2 username in GitHub Secrets
      JAR_NAME: your-app-name.jar # Make sure this matches your actual JAR file name

    steps:
    - name: Download artifact
      uses: actions/download-artifact@v4
      with:
        name: spring-boot-app

    - name: Set up SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

    - name: Deploy to EC2
      run: |
        # Add your EC2 host to known hosts to avoid fingerprint prompts
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

        # Transfer the JAR file to the EC2 instance
        scp $JAR_NAME $EC2_USER@$EC2_HOST:/home/$EC2_USER/$JAR_NAME

        # Connect to EC2 and restart the Spring Boot application
        # This assumes you have a way to stop/start your application on EC2.
        # Examples:
        # 1. Using systemd (recommended for production):
        #    ssh $EC2_USER@$EC2_HOST "sudo systemctl stop your-app-service && sudo systemctl start your-app-service"
        # 2. Simple kill and restart (less robust):
        #    ssh $EC2_USER@$EC2_HOST "pkill -f 'java -jar' && nohup java -jar /home/$EC2_USER/$JAR_NAME > /dev/null 2>&1 &"
        #
        # Choose the method that best suits your EC2 setup.
        # Replace 'your-app-service' with the actual name of your systemd service.
        ssh $EC2_USER@$EC2_HOST "
          echo 'Deployment started...'
          # Stop the existing application if it's running
          sudo systemctl stop my-spring-app || true # '|| true' to prevent failure if service isn't running
          echo 'Application stopped.'

          # Move the new JAR to its final location (optional, but good practice for organized deployments)
          # Assuming /opt/my-spring-app is where your app should reside
          sudo mv /home/$EC2_USER/$JAR_NAME /opt/my-spring-app/$JAR_NAME

          # Start the application using systemd
          sudo systemctl start my-spring-app
          echo 'Application started.'
          sudo systemctl status my-spring-app --no-pager
        "
